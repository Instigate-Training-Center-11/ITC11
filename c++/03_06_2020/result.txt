Կախված համակարգչի պրոցեսորի և հասցեավորման բիթայնությունից փոփոխականների հիշողությունները տարբեր են։
Ստատիկ և գլոբալ փոփոխականները պահվում են հիշողության մեջ առանձին (static/global) հիշողության մեջ,տեսանելի են ամբողջ ֆայլում
կյանքի տևողությունը մինչև ծրագրի ավարտն է։
Ստեկում առաջին հիշողություն զբաղեցնողը վերջինն է (մաքրվում հիշողությունից) ազատում իրեն հատկացված տարածքը։
Հարաբերականորեն ընդունենք որ ստեկի այսպես ասած հատակը նկարում պատկերված է վերևում (main() function-ի ֆրեյմը,միջավայրը)
այդ կետում պակվում է գլխաոր ֆունկցիաի՝ main()-ի ֆրեյմը, ծրագիրը հասնում է իր տրամաբանական ավարտին։Ծրագիրը սկսվում 
(աշխատում) և ավարտվում է գլխավոր  main() ֆունկցիա֊ում(սկիզբ main(){ ավարտ return 0;}):
int a = 10;
Ամենասկզբից stack-ում բացվում է  main()-ի ֆրեյմը։
stack-ի հատակում 0x7ffc80377ec8 հասեցեում առանձնացվում է (4 byt) հիշողության չափով տարածք 5 արժեքը պահելու համար փոփոխականի 
այսպես ասաց անունը որի տակ հասկացվում է 0x7ffc80377ec8 հասցեի պարունակությունը։
int& b = a;
հետո  stack֊ի 0x7ffc80377ec8 հասցեում պահվող փոփոխականի անունը դարնում է նաև b:
այսինքն  b֊ն դարնում է լինք նուին հասցեի վրա,դա նշանակում է որ stack֊ում նոր հասցե՝ հիշողություն չի առանձնացվում և a֊ն և b֊ն ունեն նուին հասցեն,
նուին արժեքը:
int* c = &b;
Հաջորդ քայլում stack֊ոմ նախորդ հիշողության տարածքի վրա առանձնացվում է նոր տարածք 0x7ffc80377ed0 (8 byt) հիշողության չափով քանի որ
փոինտեր է և հղվում է b֊ի հասցեի վրա 0x7ffc80377ec8 որը որ նուին a֊ի հասցեն է։
Հաջորդ քայլում ստեկի 0x7ffc80377ed0 հասցեի վրա՝ հերթական հասցեում (0x7ffc80377ecc (4 byt)) նստում է  նոր k փոփոխականը իր արժեքով (իրականում
հասցեները գնում են հաջորդաբար)
Հաջորդ քայլում ++(*c) a֊ի արժեքը կավելանա 1 ով քանի որ c֊ն փոինտեր էր a֊ի և b֊ի վրա։ a == 11, b == 11:
Հաջորդ քայլում ++b կրկին   b֊ի արժեքը (որը որ նուին a֊ն է) կավելանա 1 ով։ 12
Հաջորդ քայլում  0x7ffc80377ecc հասցեի վրա կգա կնստի  number֊ը (8 byt փոինտեր) 0x7ffc80377ed5 հասցեով որին վերագրվում է ֆունկցիայի կանչ,
որ էլ իր հերթին կնշանակի որ բացվում է նոր ֆրեյմ testFoo(a,c) ֆունկցիայի համար։
static int number = 3 կստեղծվի  0x55f8bc792010 հասցեով 3 արժեքով փոփոխականը որը պահվում է (static/global) հիշողության տարացքում։
Հաջորդ քայլում int f = 20 ֆունկցիայի ֆրեյմի հատակում կնստի  f փոփոխականը 0x7ffc80377e9c(4 byt) հասցեով ու այնտեղ պահում 20 արժեքը։
Հաջորդ քայլում int* temp = new int (5)։ testFoo(a,c) ֆունկցիայի ֆրեյմի հատակում  կնստի temp փոփոխականը (ինթեջր փոինթեր տիպի 8 byt) 
0x7ffc80377ea0 հասցեով որը հղվում է դինամիկ հիշողության հասցեի վրա ու այնտեղ (0x55f8bdf0fe80 դինամիկ հիշողության հասցե) պահում 5 արժեքը։
Հաջորդ քայլում   a += f կփոխի main-ի   a (a == 32) փոոփխականի արժեքը քանի որ ֆունկցիային պարամետրը  int& տիպի է և նուին main-ի a փոոփխականի
հասցեն ունի;
 *c += f ֆունկցիայի 2 պարամետրը int* տիպի է և իրեն կանչի ժամանակ արգումենտ ենք  տվել c-ն որը իր հերթին փոինտեր էր a-ի և b-ի հասցեի
վրա,որոնք ունեն նուին հասցեն,հետևվաբար նորից  a-ի արժեքը նորից կփոխվի (a == 52)
Հաջորդ քայլում դինամիկ հիշուղությունից կջնջվի temp ֊ի արժեքը ,որից հետո return &number կետում ֆունկցիայի ֆրեյմը կփակվի վերադարձնելով 
number անունով ստատիկ փոփոխականի հասցեն իսկ ֆունկցիայի բոլոր լոկալ փոփոխականները կմաքրվեն ավտոմատ կառավարվող հիշողությունից(stack);
 main ֆունկցիայի այն կետում որտեղ որ  (int* number = testFoo(a,c)) կանչվել էր testFoo ֆուկնցիան, number անունով ստատիկ փոփոխականի հասցեն
կվերագրի int* տիպի number փոփոխականին;
Եթե  main ֆունկցիաի մեջ տպենք   number փոփոխականի հասցեն և արժեքը կհամոզվենք որ չնայաց որ testFoo ֆունկցիան ավարտել է իր աշխատանքը
և մաքրվել ստեկից նրա մեջ հայտարարված static int number = 3 ստատիկ փոփոխականը դեր գոյություն ունի,այն կջնջվի միայն այն ժամանակ երփ
գլխավոր ֆունկցիան կփակվի և ծրագիրը կավարտվի։






